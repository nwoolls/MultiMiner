{
  "name": "edge",
  "author": {
    "name": "Tomasz Janczuk",
    "email": "tomasz@janczuk.org",
    "url": "http://tomasz.janczuk.org"
  },
  "version": "0.7.14",
  "description": "Edge.js: run .NET and node.js code in-process",
  "tags": [
    "owin",
    "edge",
    "net",
    "clr",
    "c#",
    "managed",
    ".net"
  ],
  "main": "./lib/edge.js",
  "engines": {
    "node": ">= 0.6"
  },
  "os": [
    "win32"
  ],
  "licenses": [
    {
      "type": "Apache",
      "url": "http://www.apache.org/licenses/LICENSE-2.0"
    }
  ],
  "dependencies": {
    "edge-cs": "0.2.4"
  },
  "devDependencies": {
    "mocha": "1.8.1",
    "jshint": "1.1.0"
  },
  "homepage": "https://github.com/tjanczuk/edge",
  "repository": {
    "type": "git",
    "url": "git@github.com:tjanczuk/edge.git"
  },
  "bugs": {
    "url": "http://github.com/tjanczuk/edge/issues"
  },
  "scripts": {
    "install": "tools\\install.bat",
    "test": "test\\test.bat",
    "jshint": "node ./tools/runJsHint.js"
  },
  "readme": "Edge.js: run .NET and Node.js code in-process\r\n====\r\n\r\nAn edge connects two nodes. This edge connects Node.js and .NET. V8 and CLR. Node.js, Python, and C# - in process.\r\n\r\n## Before you dive in\r\n\r\nSee the [Edge.js overview](http://tjanczuk.github.com/edge).  \r\nRead the [Edge.js introduction on InfoQ](http://www.infoq.com/articles/the_edge_of_net_and_node).  \r\nListen to the [Edge.js podcast on Herdingcode](http://herdingcode.com/herding-code-166-tomasz-janczuk-on-edge-js/). \r\n\r\n## Contents\r\n\r\n[Introduction](https://github.com/tjanczuk/edge#introduction)  \r\n[What you need](https://github.com/tjanczuk/edge#what-you-need)  \r\n[How to: C# hello, world](https://github.com/tjanczuk/edge#how-to-c-hello-world)  \r\n[How to: integrate C# code into Node.js code](https://github.com/tjanczuk/edge#how-to-integrate-c-code-into-nodejs-code)  \r\n[How to: specify additional CLR assembly references in C# code](https://github.com/tjanczuk/edge#how-to-specify-additional-clr-assembly-references-in-c-code)  \r\n[How to: marshal data between C# and Node.js](https://github.com/tjanczuk/edge#how-to-marshal-data-between-c-and-nodejs)  \r\n[How to: call Node.js from C#](https://github.com/tjanczuk/edge#how-to-call-nodejs-from-c)  \r\n[How to: export C# function to Node.js](https://github.com/tjanczuk/edge#how-to-export-c-function-to-nodejs)  \r\n[How to: script Python in a Node.js application](https://github.com/tjanczuk/edge#how-to-script-python-in-a-nodejs-application)  \r\n[How to: script PowerShell in a Node.js application](https://github.com/tjanczuk/edge#how-to-script-powershell-in-a-nodejs-application)  \r\n[How to: script F# in a Node.js application](https://github.com/tjanczuk/edge#how-to-script-f-in-a-nodejs-application)  \r\n[How to: script T-SQL in a node.js application](https://github.com/tjanczuk/edge#how-to-script-t-sql-in-a-nodejs-application)  \r\n[How to: support for other CLR languages](https://github.com/tjanczuk/edge#how-to-support-for-other-clr-languages)  \r\n[How to: exceptions](https://github.com/tjanczuk/edge#how-to-exceptions)  \r\n[How to: debugging](https://github.com/tjanczuk/edge#how-to-debugging)  \r\n[Performance](https://github.com/tjanczuk/edge#performance)  \r\n[Building](https://github.com/tjanczuk/edge#building)  \r\n[Running tests](https://github.com/tjanczuk/edge#running-tests)  \r\n[Contribution and derived work](https://github.com/tjanczuk/edge#contribution-and-derived-work)  \r\n\r\n## Introduction \r\n\r\nEdge.js allows you to run .NET and Node.js code in one process. You can call .NET functions from Node.js and Node.js functions from .NET. Edge.js takes care of marshaling data between CLR and V8. Edge.js also reconciles threading models of single threaded V8 and multi-threaded CLR. Edge.js ensures correct lifetime of objects on V8 and CLR heaps. The CLR code can be pre-compiled or specified as C#, F#, Python, or PowerShell source: edge.js can run CLR scripts at runtime. Edge can be extended to support other CLR languages.\r\n\r\n![F# Python C# Node.js](https://f.cloud.github.com/assets/822369/468830/a293c728-b6a3-11e2-9fb3-99c7bf2bf6ed.png)\r\n\r\nEdge.js provides a basic, prescriptive model and implementation for interoperability between .NET and Node.js in-process. You can built upon and extended this basic mechanism to support more specific scenarios, for example:\r\n* implementing express.js handlers and connect middleware for Node.js application using .NET 4.5 ([read more](http://tomasz.janczuk.org/2013/02/hosting-net-code-in-nodejs-applications.html)),  \r\n* implementing CPU-bound computations in .NET and running them in-process with Node.js application without blocking the event loop ([read more](http://tomasz.janczuk.org/2013/02/cpu-bound-workers-for-nodejs.html)),  \r\n* using C# and IronPython and .NET instead of writing native Node.js extensions in C/C++ and Win32 to access Windows specific functionality from a Node.js application ([read more](http://tomasz.janczuk.org/2013/02/access-ms-sql-from-nodejs-application.html)). \r\n\r\nRead more about the background and motivations of the project [here](http://tomasz.janczuk.org/2013/02/hosting-net-code-in-nodejs-applications.html). \r\n\r\n[Follow @tjanczuk](https://twitter.com/tjanczuk) for updates related to the module. \r\n\r\n## What you need\r\n\r\n* Windows\r\n* node.js 0.6.x or later (developed and tested with v0.6.20, v0.8.22, and v0.10.0, both x32 and x64 architectures)  \r\n* [.NET 4.5](http://www.microsoft.com/en-us/download/details.aspx?id=30653)  \r\n* to use Python, you also need [IronPython 2.7.3 or later](http://ironpython.codeplex.com/releases/view/81726)  \r\n* to use F#, read [Dave Thomas blog post](http://7sharpnine.com/posts/i-node-something/)\r\n\r\n## How to: C# hello, world\r\n\r\nInstall edge:\r\n\r\n```\r\nnpm install edge\r\n```\r\n\r\nIn your server.js:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar helloWorld = edge.func('async (input) => { return \".NET Welcomes \" + input.ToString(); }');\r\n\r\nhelloWorld('JavaScript', function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nRun and enjoy:\r\n\r\n```\r\nC:\\projects\\barebones>node server.js\r\n.NET welcomes JavaScript\r\n```\r\n\r\n## How to: integrate C# code into node.js code\r\n\r\nEdge provies several ways to integrate C# code into a node.js application. Regardless of the way you choose, the entry point into the .NET code is normalized to a `Func<object,Task<object>>` delegate. This allows node.js code to call .NET asynchronoulsy and avoid blocking the node.js event loop. \r\n\r\nEdge provides a function that accepts a reference to C# code in one of the supported representations, and returns a node.js function which acts as a JavaScript proxy to the `Func<object,Task<object>>` .NET delegate:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar myFunction = edge.func(...);\r\n```\r\n\r\nThe function proxy can then be called from node.js like any asynchronous function:\r\n\r\n```javascript\r\nmyFunction('Some input', function (error, result) {\r\n    //...\r\n});\r\n```\r\n\r\nAlternatively, if you know the C# implementation will complete synchronously given the circumstances, you can call this function as any synchronous JavaScript function as follows:\r\n\r\n```javascript\r\nvar result = myFunction('Some input', true);\r\n```\r\n\r\nThe `true` parameter instead of a callback indicates that node.js expects the C# implementation to complete synchronsouly. If the CLR function implementation does not complete synchronously, the call above will result in an exception. \r\n\r\nOne representation of CLR code that edge.js accepts is C# source code. You can embed C# literal representing a .NET async lambda expression implementing the `Func<object,Task<object>>` delegate directly inside node.js code:\r\n\r\n```javascript\r\nvar add7 = edge.func('async (input) => { return (int)input + 7; }');\r\n``` \r\n\r\nIn antoher representation, you can embed multi-line C# source code by providing a function with a body containing a multi-line comment. Edge extracts the C# code from the function body using regular expressions:\r\n\r\n```javascript\r\nvar add7 = edge.func(function() {/*\r\n    async (input) => {\r\n        return (int)input + 7;\r\n    }\r\n*/});\r\n```\r\n\r\nIf your C# code is more involved than a simple lambda, you can specify entire class definition. By convention, the class must be named `Startup` and it must have an `Invoke` method that matches the `Func<object,Task<object>>` delegate signature. This method is useful if you need to factor your code into multiple methods:\r\n\r\n```javascript\r\nvar add7 = edge.func(function() {/*\r\n    using System.Threading.Tasks;\r\n\r\n    public class Startup\r\n    {\r\n        public async Task<object> Invoke(object input)\r\n        {\r\n            int v = (int)input;\r\n            return Helper::AddSeven(v);\r\n        }\r\n    }\r\n\r\n    static class Helper\r\n    {\r\n        public static int AddSeven(int v) \r\n        {\r\n            return v + 7;\r\n        }\r\n    }\r\n*/});\r\n```\r\n\r\nIf your C# code grows substantially, it is useful to keep it in a separate file. You can save it to a file with `*.csx` or `*.cs` extension, and then reference from your node.js application:\r\n\r\n```javascript\r\nvar add7 = edge.func(__dirname + '/add7.csx');\r\n```\r\n\r\nIf you integrate C# code into your node.js application by specifying C# source using one of he methods above, edge will compile the code on the fly. If you prefer to pre-compile your C# sources to a CLR assembly, or if your C# component is already pre-compiled, you can reference a CLR assembly from your node.js code. In the most generic form, you can specify the assembly file name, the type name, and the method name when creating a node.js proxy to a .NET method:\r\n\r\n```javascript\r\nvar clrMethod = edge.func({\r\n    assemblyFile: 'My.Edge.Samples.dll',\r\n    typeName: 'Samples.FooBar.MyType',\r\n    methodName: 'MyMethod'\r\n});\r\n```\r\n\r\nIf you don't specify methodName, `Invoke` is assumed. If you don't specify typeName, a type name is constucted by assuming the class called `Startup` in the namespace equal to the assembly file name (without the `.dll`). In the example above, if typeName was not specified, it would default to `My.Edge.Samples.Startup`.\r\n\r\nThe assemblyFile is relative to the working directory. If you want to locate your assembly in a fixed location relative to your node.js application, it is useful to constuct the assemblyFile using `__dirname`. \r\n\r\nYou can also create node.js proxies to .NET functions specifying just the assembly name as a parameter:\r\n\r\n```javascript\r\nvar clrMethod = edge.func('My.Edge.Samples.dll');\r\n```\r\n\r\nIn that case the default typeName of `My.Edge.Samples.Startup` and methodName of `Invoke` is assumed as explained above. \r\n\r\n## How to: specify additional CLR assembly references in C# code\r\n\r\nWhen you provide C# source code and let edge compile it for you at runtime, edge will by default reference only mscorlib.dll and System.dll assemblies. In applications that require additional assemblies you can specify them in C# code using a special comment pattern. For example, to use ADO.NET you must reference System.Data.dll:\r\n\r\n```javascript\r\nvar add7 = edge.func(function() {/*\r\n\r\n    //#r \"System.Data.dll\"\r\n\r\n    using System.Data;\r\n    using System.Threading.Tasks;\r\n\r\n    public class Startup\r\n    {\r\n        public async Task<object> Invoke(object input)\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n*/});\r\n```\r\n\r\nIf you prefer, instead of using comments you can specify references by providing options to the `edge.func` call:\r\n\r\n```javascript\r\nvar add7 = edge.func({\r\n    source: function() {/*\r\n\r\n        using System.Data;\r\n        using System.Threading.Tasks;\r\n\r\n        public class Startup\r\n        {\r\n            public async Task<object> Invoke(object input)\r\n            {\r\n                // ...\r\n            }\r\n        }\r\n    */},\r\n    references: [ 'System.Data.dll' ]\r\n);\r\n```\r\n\r\n## How to: marshal data between C# and node.js\r\n\r\nEdge.js can marshal any JSON-serializable value between .NET and node.js (although JSON serializaton is not used in the process). Edge also supports marshaling between node.js `Buffer` instance and a .NET `byte[]` array to help you efficiently pass binary data.\r\n\r\nYou can call .NET from node.js and pass in a complex JavaScript object as follows:\r\n\r\n```javascript\r\nvar dotNetFunction = edge.func('Edge.Sample.dll');\r\n\r\nvar payload = {\r\n    anInteger: 1,\r\n    aNumber: 3.1415,\r\n    aString: 'foo',\r\n    aBoolean: true,\r\n    aBuffer: new Buffer(10),\r\n    anArray: [ 1, 'foo' ],\r\n    anObject: { a: 'foo', b: 12 }\r\n};\r\n\r\ndotNetFunction(payload, function (error, result) { });\r\n```\r\n\r\nIn .NET, JavaScript objects are represented as `IDictionary<string,object>`, JavaScript arrays as `object[]`, and JavaScript `Buffer` as `byte[]`. Scalar JavaScript values have their corresponding .NET types (`int`, `double`, `bool`, `string`). Here is how you can acces the data in .NET:\r\n\r\n```c#\r\nusing System.Collections.Generic;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Edge.Sample\r\n{\r\n    public class Startup\r\n    {\r\n        public async Task<object> Invoke(object input)\r\n        {\r\n            IDictionary<string, object> payload = (IDictionary<string,object>)input;\r\n            int anInteger = (int)payload[\"anInteger\"];\r\n            double aNumber = (double)payload[\"aNumber\"];\r\n            string aString = (string)payload[\"aString\"];\r\n            bool aBoolean = (bool)payload[\"aBoolean\"];\r\n            byte[] aBuffer = (byte[])payload[\"aBuffer\"];\r\n            object[] anArray = (object[])payload[\"anArray\"];\r\n            IDictionary<string, object> anObject = (IDictionary<string,object>)payload[\"anObject\"];\r\n\r\n            return null;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nSimilar type marshaling is applied when .NET code passes data back to node.js code. In .NET code you can provide an instance of any CLR type that would normally be JSON serializable, including domain specific types like `Person` or anonymous objects. For example:\r\n\r\n```c#\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Edge.Sample\r\n{\r\n    public class Person\r\n    {\r\n        public int anInteger = 1;\r\n        public double aNumber = 3.1415;\r\n        public string aString = \"foo\";\r\n        public bool aBoolean = true;\r\n        public byte[] aBuffer = new byte[10];\r\n        public object[] anArray = new object[] { 1, \"foo\" };\r\n        public object anObject = new { a = \"foo\", b = 12 };\r\n    }\r\n\r\n    public class Startup\r\n    {\r\n        public async Task<object> Invoke(object input)\r\n        {\r\n            Person person = new Person();\r\n            return person;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nIn your node.js code that invokes this .NET method you can display the result object that the callback method receives:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar getData = edge.func('Edge.Sample.dll');\r\n\r\ngetData(null, function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nPassing this .NET object to node.js generates a JavaScript object as follows:\r\n\r\n```\r\nC:\\projects\\barebones>node sample.js\r\n{ anInteger: 1,\r\n  aNumber: 3.1415,\r\n  aString: 'foo',\r\n  aBoolean: true,\r\n  aBuffer: <Buffer 00 00 00 00 00 00 00 00 00 00>,\r\n  anArray: [ 1, 'foo' ],\r\n  anObject: { a: 'foo', b: 12 } }\r\n```\r\n\r\nWhen data is marshaled from .NET to node.js, no checks for circular references are made. They will typically result in stack overflows. Make sure the object graph you are passing from .NET to node.js is a tree and does not contain any cycles. \r\n\r\nWhen marshaling strongly typed objects (e.g. Person) form .NET to node.js, you can optionaly tell edge.js to observe the [System.Web.Script.Serialization.ScriptIgnoreAttribute](http://msdn.microsoft.com/en-us/library/system.web.script.serialization.scriptignoreattribute.aspx). You opt in to this behavior by setting the `EDGE_ENABLE_SCRIPTIGNOREATTRIBUTE` environment variable:\r\n\r\n```\r\nset EDGE_ENABLE_SCRIPTIGNOREATTRIBUTE=1\r\n```\r\n\r\nEdge.js by default does not observe the ScriptIgnoreAttribute to avoid the associated performance cost. \r\n\r\n## How to: call node.js from C#  \r\n\r\nIn addition to marshaling data, edge can marshal proxies to JavaScript functions when invoking .NET code from node.js. This allows .NET code to call back into node.js. \r\n\r\nSuppose the node.js application passes an `add` function to the .NET code as a property of an object. The function receives two numbers and returns the sum of them via the provided callback:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar multiplyBy2 = edge.func('Edge.Sample.dll');\r\n\r\nvar payload = {\r\n    someParameter: 'arbitrary parameter',\r\n    add: function (data, callback) {\r\n        callback(null, data.a + data.b);\r\n    }\r\n};\r\n\r\nmultiplyBy2(payload, function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nThe .NET code implements the multiplyBy2 function. It generates two numbers, calls back into the `add` function exported from node.js to add them, multiples the result by 2 in .NET, and returns the result back to node.js:\r\n\r\n```c#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Edge.Sample\r\n{\r\n    public class Startup\r\n    {\r\n        public async Task<object> Invoke(IDictionary<string, object> input)\r\n        {\r\n            Func<object, Task<object>> add = (Func<object, Task<object>>)input[\"add\"];\r\n            var twoNumbers = new { a = 2, b = 3 };\r\n            var addResult = (int)await add(twoNumbers);\r\n            return addResult * 2;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe node.js function exported from node.js to .NET must follow the prescriptive async pattern of accepting two parameters: payload and a callback. The callback function accepts two parametrs. The first one is the error, if any, and the second the result of the operation:\r\n\r\n```javasctipt\r\nfunction (payload, callback) {\r\n    var error;  // must be null or undefined in the absence of error\r\n    var result; \r\n\r\n    // do something\r\n\r\n    callback(error, result);\r\n}\r\n```\r\n\r\nThe proxy to that function in .NET has the following signature:\r\n\r\n```c#\r\nFunc<object,Task<object>>\r\n```\r\n\r\nUsing TPL in CLR to provide a proxy to an asynchronous node.js function allows the .NET code to use the convenience of the `await` keyword when invoking the node.js functionality. The example above shows the use of the `await` keyword when calling the proxy of the node.js `add` method.  \r\n\r\n## How to: export C# function to node.js\r\n\r\nSimilarly to marshaling functions from node.js to .NET, edge.js can also marshal functions from .NET to node.js. The .NET code can export a `Func<object,Task<object>>` delegate to node.js as part of the return value of a .NET method invocation. For example:\r\n\r\n```javascript\r\nvar createHello = edge.func(function () {/*\r\n    async (input) =>\r\n    {\r\n        return (Func<object,Task<object>>)(async (i) => { \r\n            Console.WriteLine(\"Hello from .NET\"); \r\n            return null; \r\n        });\r\n    }\r\n*/});\r\n\r\nvar hello = createHello(null, true); \r\nhello(null, true); // prints out \"Hello from .NET\"\r\n```\r\n\r\nThis mechanism in conjunction with a closure can be used to expose CLR class instances or CLR state in general to JavaScript. For example:\r\n\r\n```javascript\r\nvar createCounter = edge.func(function () {/*\r\n    async (input) =>\r\n    {\r\n        var k = (int)input; \r\n        return (Func<object,Task<object>>)(async (i) => { return ++k; });\r\n    }\r\n*/});\r\n\r\nvar counter = createCounter(12, true); // create counter with 12 as initial state\r\nconsole.log(counter(null, true)); // prints 13\r\nconsole.log(counter(null, true)); // prints 14\r\n```\r\n\r\n## How to: script Python in a node.js application\r\n\r\nEdge.js enables you to run Python and node.js in-process.\r\n\r\nYou need Windows, [node.js](http://nodejs.org) (any stable version 0.6.x or later), [.NET 4.5](http://www.microsoft.com/en-us/download/details.aspx?id=30653), and [IronPython 2.7.3](http://ironpython.codeplex.com/releases/view/81726) to proceed.\r\n\r\n### Hello, world\r\n\r\nInstall edge and edge-py modules:\r\n\r\n```\r\nnpm install edge\r\nnpm install edge-py\r\n```\r\n\r\nIn your server.js:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar hello = edge.func('py', function () {/*\r\n    def hello(input):\r\n        return \"Python welcomes \" + input\r\n\r\n    lambda x: hello(x)\r\n*/});\r\n\r\nhello('Node.js', function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nRun and enjoy:\r\n\r\n```\r\nC:\\projects\\edgerepro>node py.js\r\nPython welcomes Node.js\r\n```\r\n\r\n### The interop model\r\n\r\nYour Python script must evaluate to a lambda expression that accepts a single parameter. The parameter represents marshalled input from the node.js code. The return value of the lambda expression is passed back as the result to node.js code. The Python script can contain constructs (e.g. Python functions) that are used in the closure of the lambda expression. The instance of the script with associated state is created when `edge.func` is called in node.js. Each call to the function referes to that instance.\r\n\r\nThe simplest *echo* Python script you can embed in node.js looks like this:\r\n\r\n```python\r\nlambda x: x\r\n```\r\n\r\nTo say hello, you can use something like this:\r\n\r\n```python\r\nlambda: x: \"Hello, \" + x\r\n```\r\n\r\nTo maintain a running sum of numbers:\r\n\r\n```python\r\ncurrent = 0\r\n\r\ndef add(x):\r\n    global current\r\n    current = current + x\r\n    return current\r\n\r\nlambda x: add(x)\r\n```\r\n\r\n### Python in its own file\r\n\r\nYou can reference Python script stored in a *.py file instead of embedding Python code in a node.js script.\r\n\r\nIn your hello.py file:\r\n\r\n```python\r\ndef hello(input):\r\n    return \"Python welcomes \" + input\r\n\r\nlambda x: hello(x)\r\n```\r\n\r\nIn your hello.js file:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar hello = edge.func('py', 'hello.py');\r\n\r\nhello('Node.js', function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nRun and enjoy:\r\n\r\n```\r\nC:\\projects\\edgerepro>node hello.js\r\nPython welcomes Node.js\r\n```\r\n\r\n### To sync or to async, that is the question\r\n\r\nIn the examples above Pythion script was executing asynchronously on its own thread without blocking the singleton V8 thread on which the node.js event loop runs. This means your node.js application remains reponsive while the Python code executes in the background. \r\n\r\nIf know your Python code is non-blocking, or if your know what your are doing, you can tell edge.js to execute Python code on the singleton V8 thread. This will improve performance for non-blocking Python scripts embedded in a node.js application:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar hello = edge.func('py', {\r\n    source: function () {/*\r\n        def hello(input):\r\n            return \"Python welcomes \" + input\r\n\r\n        lambda x: hello(x)\r\n    */},\r\n    sync: true\r\n});\r\n\r\nconsole.log(hello('Node.js', true));\r\n```\r\n\r\nThe `sync: true` property in the call to `edge.func` tells edge.js to execute Python code on the V8 thread as opposed to creating a new thread to run Python script on. The `true` parameter in the call to `hello` requests that edge.js does in fact call the `hello` function synchronously, i.e. return the result as opposed to calling a callback function. \r\n\r\n## How to: script PowerShell in a node.js application\r\n\r\nEdge.js enables you to run PowerShell and node.js in-process. [Edge-PS](https://github.com/dfinke/edge-ps) connects the PowerShell ecosystem with 24k+ npm modules and more.\r\n\r\nYou need Windows, [node.js](http://nodejs.org) (any stable version 0.6.x or later), [.NET 4.5](http://www.microsoft.com/en-us/download/details.aspx?id=30653), and [PowerShell 3.0](http://www.microsoft.com/en-us/download/details.aspx?id=34595) to proceed.\r\n\r\n### Hello, world\r\n\r\nInstall edge and edge-ps modules:\r\n\r\n``` \r\nnpm install edge\r\nnpm install edge-ps\r\n```\r\n\r\nIn your server.js:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar hello = edge.func('ps', function () {/*\r\n\"PowerShell welcomes $inputFromJS on $(Get-Date)\"\r\n*/});\r\n\r\nhello('Node.js', function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result[0]);\r\n});\r\n```\r\n\r\nRun and enjoy:\r\n\r\n```\r\nC:\\testEdgeps>node server\r\nPowerShell welcomes Node.js on 05/04/2013 09:38:40\r\n```\r\n\r\n### Tapping into PowerShell's ecosystem\r\n\r\nRather than embedding PowerShell directly, you can use PowerShell files, dot source them and even use *Import-Module*.\r\n\r\nWhat you can do in native PowerShell works in node.js.\r\n\r\n### Interop PowerShell and Python\r\n\r\nHere you can reach out to IronPython from PowerShell from within node.js. This holds true for working with JavaScript frameworks and C#.\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar helloPowerShell = edge.func('ps', function () {/*\r\n\t\"PowerShell welcomes $inputFromJS\"\r\n*/});\r\n\r\nvar helloPython = edge.func('py', function () {/*\r\n    def hello(input):\r\n        return \"Python welcomes \" + input\r\n\r\n    lambda x: hello(x)\r\n*/});\r\n\r\n\r\nhelloPython('Node.js', function(error, result){\r\n\tif(error) throw error;\r\n\r\n\thelloPowerShell(result, function(error, result){\r\n\t\tif(error) throw error;\r\n\t\tconsole.log(result[0]);\r\n\t});\r\n});\r\n```\r\n\r\n## How to: script F# in a node.js application\r\n\r\nThis section is coming up. In the meantime please refer to [Dave Thomas blog post](http://7sharpnine.com/posts/i-node-something/).\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar helloFs = edge.func('fs', function () {/*\r\n    fun input -> async { \r\n        return \"F# welcomes \" + input.ToString()\r\n    }\r\n*/});\r\n\r\nhelloFs('Node.js', function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\n## How to: script T-SQL in a node.js application\r\n\r\nThe edge-sql extension of edge.js allows for accessing MS SQL databases by scripting T-SQL inside the Node.js application. The edge-sql extension uses async ADO.NET SQL client to access MS SQL. \r\n\r\nYou need Windows, [node.js](http://nodejs.org) (any stable version 0.6.x or later), and [.NET 4.5](http://www.microsoft.com/en-us/download/details.aspx?id=30653). To run the sample code below you also need a connection string to the sample Northwind database that ships with MS SQL. \r\n\r\n### Hello, world\r\n\r\nInstall edge and edge-sql modules:\r\n\r\n```\r\nnpm install edge\r\nnpm install edge-sql\r\n```\r\n\r\nSet the connection string as an enironment variable (your connection string may be different):\r\n\r\n```\r\nset EDGE_SQL_CONNECTION_STRING=Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True\r\n```\r\n\r\nIn your server.js:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar getTop10Products = edge.func('sql', function () {/*\r\n    select top 10 * from Products \r\n*/});\r\n\r\ngetTop10Product(null, function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nRun and enjoy:\r\n\r\n```\r\nC:\\projects\\edge\\samples>node server.js\r\n[ [ 'ProductID',\r\n    'ProductName',\r\n    'SupplierID',\r\n    'CategoryID',\r\n    'QuantityPerUnit',\r\n    'UnitPrice',\r\n    'UnitsInStock',\r\n    'UnitsOnOrder',\r\n    'ReorderLevel',\r\n    'Discontinued' ],\r\n  [ 10,\r\n    'New Ikura',\r\n    4,\r\n    8,\r\n    '12 - 200 ml jars',\r\n    '31.0000',\r\n    '31',\r\n    '0',\r\n    '0',\r\n    false ],\r\n    ...\r\n```\r\n\r\n### Parameterized queries\r\n\r\nYou can construct a parameterized query once and provide parameter values on a per-call basis:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar getProduct = edge.func('sql', function () {/*\r\n    select * from Products \r\n    where ProductId = @myProductId\r\n*/});\r\n\r\ngetProduct({ myProductId: 10 }, function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\n### Basic CRUD support: select, update, insert, delete\r\n\r\nThe four basic CRUD operations are supported. For example, here is how an update can look like:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar updateProductName = edge.func('sql', function () {/*\r\n    update Products\r\n    set ProductName = @newName \r\n    where ProductId = @myProductId\r\n*/});\r\n\r\nupdateProductName({ myProductId: 10, newName: 'New Ikura' }, function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\n## How to: support for other CLR languages\r\n\r\nEdge.js can work with any pre-compiled CLR assembly that contains the `Func<object,Task<object>>` delegate. Out of the box, edge.js also allows you to embed C# source code in a node.js application and compile it on the fly. With the use of the `edge-py` module, edge.js can also execute embedded IronPython script. \r\n\r\nTo enable compilation of other CLR languages (e.g. F#) at runtime or to support other idioms of constructing C# script, you can use the compiler composibility model provided by edge.js. Please read the [add support for a CLR language](https://github.com/tjanczuk/edge/wiki/Add-support-for-a-CLR-language) guide to get started. \r\n\r\n## How to: exceptions\r\n\r\nEdge.js marshals node.js errors and exceptions to .NET as well as .NET exceptions to node.js. \r\n\r\nCLR exceptions thrown in .NET code invoked from node.js are marshaled as the `error` parameter to the node.js callback function. Consider this .NET code:\r\n\r\n```c#\r\npublic Task<object> Invoke(object input)\r\n{\r\n    throw new Exception(\"Sample .NET exception\");\r\n}\r\n```\r\n\r\nAnd the node.js code that invokes this .NET function and re-throws the `error` parameter passed to the JavaScript callback function:\r\n\r\n```javascript\r\nvar edge = require('edge');\r\n\r\nvar clrFunc = edge.func('Edge.Sample.dll');\r\n\r\nclrFunc(null, function (error, result) {\r\n    if (error) throw error;\r\n});\r\n```\r\n\r\nRunning this node.js application shows that the CLR exception was indeed received by the node.js callback. The `error` parameter contains the full stack trace including the CLR code path:\r\n\r\n```\r\nC:\\projects\\barebones>node sample.js\r\n\r\nc:\\projects\\edge\\lib\\edge.js:58\r\n                edge.callClrFunc(appId, data, callback);\r\n                     ^\r\nSystem.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. \r\n---> System.Exception: Sample .NET exception\r\n   at Edge.Sample.Startup.Invoke(Object input) in c:\\projects\\barebones\\sample.cs:line 12\r\n``` \r\n\r\nJavaScript exceptions thrown in node.js code invoked from .NET are wrapped in a CLR exception and cause the asynchronous `Task<object>` to complete with a failure. Errors passed by node.js code invoked from .NET code to the callback function's `error` parameter have the same effect. \r\n\r\nThis node.js code invokes a .NET routine and exports the `aFunctionThatThrows` JavaScript function to it:\r\n\r\n```javascript\r\nvar edge = require('edge.js');\r\nvar multiplyBy2 = edge.func('Edge.Sample.dll');\r\n\r\nvar payload = {\r\n    someParameter: 'arbitrary parameter',\r\n    aFunctionThatThrows: function (data, callback) {\r\n        throw new Error('Sample JavaScript error');\r\n    }\r\n};\r\n\r\nmultiplyBy2(payload, function (error, result) {\r\n    if (error) throw error;\r\n    console.log(result);\r\n});\r\n```\r\n\r\nThe .NET code calls the node.js function, catches any resulting CLR exceptions, and displays them:\r\n\r\n```c#\r\npublic async Task<object> Invoke(object input)\r\n{\r\n    IDictionary<string, object> payload = (IDictionary<string, object>)input;\r\n    Func<object, Task<object>> aFunctionThatThrows = (Func<object, Task<object>>)payload[\"aFunctionThatThrows\"];\r\n    try {\r\n        var aResult = await aFunctionThatThrows(null);\r\n    }\r\n    catch(Exception e)\r\n    {\r\n        Console.WriteLine(e);\r\n    }\r\n\r\n    return null;\r\n}\r\n```\r\n\r\nRunning the code shows the .NET code receiving a CLR exception as a result of the node.js function throwing a JavaScript error. The exception shows the complete stack trace, including the part that executed in the node.js code:\r\n\r\n```\r\nC:\\projects\\barebones>node sample.js\r\nSystem.Exception: Error: Sample JavaScript error\r\n    at payload.aFunctionThatThrows (C:\\projects\\barebones\\sample.js:7:11)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Edge.Sample.Startup.<Invoke>d__0.MoveNext()\r\n```\r\n\r\n## How to: debugging\r\n\r\nYou can debug the .NET code running as part of your node.js application by attaching a managed code debugger (e.g. Visual Studio) to node.exe. You can debug .NET code in a pre-compiled CLR assembly as well C# literals embedded in the application and compiled by edge.js at runtime. \r\n\r\n### Debugging pre-compiled .NET code\r\n\r\nIf you have integrated .NET code into a node.js application using a pre-compiled CLR assembly like this:\r\n\r\n```javascript\r\nvar hello = edge.func('My.Assembly.dll');\r\n```\r\n\r\nthen the best way to debug your .NET code is to attach a managed code debugger (e.g. Visual Studio) to the node.exe process. Since the node.exe process runs both native and managed code, make sure to select managed code type as target:\r\n\r\n![debug](https://f.cloud.github.com/assets/822369/190564/a41bab2c-7efb-11e2-878f-82ae2325876c.PNG)\r\n\r\nFrom there, you can set breakpoints in your .NET code and the debugger will stop when they are reached.\r\n\r\n### Debugging embedded C# code\r\n\r\nDebugging embedded C# code requires that `EDGE_CS_DEBUG` environment variable is set in the environment of the node.exe process:\r\n\r\n```\r\nset EDGE_CS_DEBUG=1\r\n```\r\n\r\nWithout this setting (the default), edge.js will not generate debugging information when compiling embedded C# code.\r\n\r\nYou can debug C# code embedded into a node.js application using a reference to a *.cs or *.csx file:\r\n\r\n```javacript\r\nvar hello = edge.func('MyClass.cs');\r\n```\r\n\r\nYou can also debug C# code embeeded directly into a *.js file using the function comment syntax:\r\n\r\n```javscript\r\nvar hello = edge.func(function () {/*\r\n    async (input)\r\n    {\r\n        System.Diagnostics.Debugger.Break();\r\n        var result = \".NET welcomes \" + input.ToString();\r\n        return result;\r\n    }\r\n*/});\r\n```\r\n\r\nYou *cannot* debug C# code embedded as a simple string literal:\r\n\r\n```javascript\r\nvar hello = edge.func('async (input) => { return 2 * (int)input; }');\r\n```\r\n\r\nAfter setting `EDGE_CS_DEBUG=1` environment variable before starting node.exe and attaching the managed debugger to the node.exe process, you can set breakpoints in C# code (which may appear as a JavaScript comment), or use `System.Diagnostics.Debugger.Break()` to break into the debugger from .NET code. \r\n\r\n![debug-inline](https://f.cloud.github.com/assets/822369/326781/923d870c-9b4a-11e2-8f45-201a6431afbf.PNG)\r\n\r\n## Performance\r\n\r\nRead more about [performance of edge.js on the wiki](https://github.com/tjanczuk/edge/wiki/Performance). Here is the gist of the latency (smaller is better):\r\n\r\n![edgejs-performance1](https://f.cloud.github.com/assets/822369/486393/645f696a-b920-11e2-8a20-9fa6932bb092.png)\r\n\r\n## Building\r\n\r\nYou must have Visual Studio 2012 toolset, Python 2.7.x, and node-gyp installed for building.\r\n\r\nTo build and test the project against all supported versions of node.js in x86 and x64 flavors, run the following:\r\n\r\n```\r\ntools\\buildall.bat\r\ntest\\testall.bat\r\nnpm run jshint\r\n```\r\n\r\nTo build one of the versions of node.js officially released by [node.js](http://nodejs.org/dist), do the following:\r\n\r\n```\r\ncd tools\r\nbuild.bat release 0.10.0\r\n```\r\n\r\nNote: the node.js version number you provide must be version number corresponding to one of the subdirectories of http://nodejs.org/dist. The command will build both x32 and x64 architectures (assuming you use x64 machine). The command will also copy the edge.node executables to appropriate locations under lib\\native directory where they are looked up from at runtime. The `npm install` step copies the C standard library shared DLL to the location of the edge.node for the component to be ready to go.\r\n\r\nTo build the C++\\CLI native extension using the version of node.js installed on your machine, issue the followig command:\r\n\r\n```\r\nnpm install -g node-gyp\r\nnode-gyp configure --msvs_version=2012\r\nnode-gyp build -debug\r\n```\r\n\r\nYou can then set the EDGE_NATIVE environment variable to the fully qualified file name of the built edge.node binary. It is useful during development, for example:\r\n\r\n```\r\nset EDGE_NATIVE=C:\\projects\\edge\\build\\Debug\\edge.node\r\n``` \r\n\r\nYou can also set the `EDGE_DEBUG` environment variable to 1 to have the edge module generate debug traces to the console when it runs.\r\n\r\n## Running tests\r\n\r\nYou must run tests from a place that has `csc.exe` to VS 2012 tooset on the PATH, for example the VS 2012 developer command prompt. To run the tests using the version node.js installed you your system:\r\n\r\n```\r\nnpm test\r\n```\r\n\r\nThis first builds a CLR assembly in C# that contains the .NET code of the tests, and then runs the tests with mocha.\r\n\r\nIf you want to run tests after building against a specific version of node.js that one of the previous builds used, issue the following command:\r\n\r\n```\r\ncd test\r\ntest.bat ia32 0.10.0\r\n```\r\n\r\nWhich will run the tests using node.js x86 v0.1.0. Similarly:\r\n\r\n```\r\ncd test\r\ntest.bat x64 0.8.22\r\n```\r\n\r\nWould run tests against node.js 0.8.22 on x64 architecture.\r\n\r\nLastly, you can run jshint on the project with:\r\n\r\n```\r\nnpm run jshint\r\n```\r\n\r\n## Contribution and derived work\r\n\r\nI do welcome contributions via pull request and derived work. \r\n\r\nThe edge module is intended to remain a very small component with core functionality that supports interop between .NET and node.js. Domain specific functionality (e.g. access to SQL, writing to ETW, writing connect middleware in .NET) should be implemented as separate modules with a dependency on edge. When you have a notable derived work, I would love to know about it to include a pointer here.  \r\n\r\n## More\r\n\r\nIssues? Feedback? You [know what to do](https://github.com/tjanczuk/edge/issues/new). Pull requests welcome.\r\n",
  "readmeFilename": "README.md",
  "_id": "edge@0.7.14",
  "_from": "edge@"
}
